---
title: "Rule start stop and electricity plot"
author: "Yujie Xu"
date: "3/15/2019"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```

A simplified ridge regression model is fitted

$$Electricity_{t} = \beta_0 + \sum_{c, r}\beta_{c,r}(\text{# component of type c with rule r triggered}) + \gamma \text{temperature}_t$$

# Occupied period

```{r occ, fig.height=3}
library("dplyr")
library("ggplot2")
library("DBI")
library("pipeR")

library("glmnet")

energytype = "kWh Del Int"
## restrict to summer
time.min.str="2018-06-01"
time.max.str="2018-09-01"

# gsalink_buildings = c("OH0192ZZ", "TN0088ZZ", "IN1703ZZ", "DC0084ZZ")
gsalink_buildings = c("OH0192ZZ")

set.seed(0)

fitting <- function(method, y, x) {
# fitting <- function(method, y, x, x.to.predict) {
  if (nrow(df) > 0) {
    ## this usually return NA's for some coef, meaning there are colinear input features
    if (method == "linear") {
      occ_out = lm(y ~ x)
      print(summary(occ_out))
      fitted.values = fitted.values(occ_out)
      print(head(fitted.values))
      print(sum(fitted.values))
      newdata = x.to.predict %>%
        tibble:::as.tibble()
      predicted.values = predict(occ_out, newdata=newdata)
      print(head(predicted.values))
      print(sum(predicted.values))
      return(list("fitted.values"=fitted.values, "predicted.values"=predicted.values))
    } else if (method == "ridge") {
      lambdas <- 10^seq(3, -2, by = -.1)
      cv_fit <- cv.glmnet(x, y, alpha = 0, lambda = lambdas)
      ## print(cv_fit$lambda.min)
      ## plot(cv_fit)
      ## fit <- cv_fit$glmnet.fit
      ## print(summary(fit))
      print(coef(cv_fit, s="lambda.min") %>>%
            `[`(rownames(.) != "(Intercept)",,drop=FALSE) %>>%
            round(4-ceiling(max(log10(abs(.)))))
            )
    }
  }
}

method = "ridge"
component = ""
for (b in gsalink_buildings[1:1]) {
  df = readr::read_csv(sprintf("../data-raw/building_rule_energy_weather/%s_%s_2018.csv",
                               b, energytype)) %>%
    tibble::as.tibble() %>%
    {.}
  if (nrow(df) == 0) {
    next
  }
  print(b)
  ## print(head(df))
  df_occ = df %>%
    dplyr::filter(is.occupied == "Occupied") %>%
    dplyr::select(-is.occupied, -hour, -day) %>%
    {.}
  time = df_occ$Timestamp
  y = df_occ[[energytype]]
  x = df_occ %>%
    dplyr::select(-!!rlang::sym(energytype), -Timestamp) %>%
    as.matrix()
  # x.to.predict = df_occ %>%
  #   dplyr::select(-!!rlang::sym(energytype), -Timestamp) %>%
  #   dplyr::mutate_at(vars(starts_with(sprintf("%s----%s", r, component))), funs({0})) %>%
    as.matrix() %>%
    {.}
  # result = fitting(method, y, x, x.to.predict)
  result = fitting(method, y, x, x.to.predict)
}
```